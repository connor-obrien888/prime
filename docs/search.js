window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "primesw", "modulename": "primesw", "kind": "module", "doc": "<p>Python package <code>primesw</code> is an implementation of the Probabilistic Regressor for Input to the Magnetosphere Estimation (PRIME) L1-to-Earth solar wind propagation algorithm.\nFor details on the algorithm development, see the <a href=\"https://www.frontiersin.org/articles/10.3389/fspas.2023.1250779/full\">paper</a>.\nInstall with:</p>\n\n<pre><code>pip install primesw\n</code></pre>\n\n<h2 id=\"why-use-prime\">Why Use PRIME?</h2>\n\n<p>PRIME is a probabilistic recurrent neural network trained to predict the solar wind conditions just upstream of Earth's bow shock using measurements of the solar wind at the first Earth-Sun Lagrange point (L1). PRIME is capable of predicting:</p>\n\n<ul>\n<li>Solar wind flow velocity vector (km/s) in GSE coordinates</li>\n<li>Interplanetary magnetic field vector (nT) in GSM coordinates</li>\n<li>Solar wind plasma number density (cm^-3)</li>\n</ul>\n\n<p>PRIME's predictions consist of a mean and a variance defining a Gaussian probability distribution for each parameter. \nUsers can use these distributions to define confidence intervals, error bars, or another measure of uncertainty suited for the user's task.\nPRIME's probability distributions are reliable to within 3.5% on average, and the means of the distribution are shown to be more accurate predictors of the solar wind than the outputs of other common solar wind propagation algorithms (see the <a href=\"https://www.frontiersin.org/articles/10.3389/fspas.2023.1250779/full\">paper</a> for more details).</p>\n\n<h2 id=\"predicting-with-prime\">Predicting with PRIME</h2>\n\n<p>Making predictions with PRIME using the <code>primesw</code> package is done using the <code>primesw.prime</code> class. <code>primesw.prime</code> objects wrap an instance of PRIME that can be used to predict the solar wind conditions at Earth's bow shock nose given a time range:</p>\n\n<pre><code>import primesw as psw\npropagator = psw.prime()\npropagator.predict(start = '2020-01-01 00:00:00', stop = '2020-01-02 00:00:00')\n</code></pre>\n\n<p><code>primesw.prime</code> objects can also make predictions at locations other than Earth's bow shock nose by passing a location given in Geocentric Solar Ecliptic coordinates:</p>\n\n<pre><code>propagator.predict(start = '2020-01-01 00:00:00', stop = '2020-01-02 00:00:00', pos = [13, 5, 0])\n</code></pre>\n\n<p>Users can also generate synthetic L1 solar wind data using the <code>primesw.prime.build_synth_input</code> method in order to use PRIME to study solar wind propagtion in a theoretical sense. It is not recommended to use PRIME to predict the solar wind in areas it was not trained on, or using inputs outside the range of solar wind conditions it was trained on.</p>\n\n<h2 id=\"citation\">Citation</h2>\n\n<p>If you make use of PRIME, please cite it:</p>\n\n<pre><code>@article{obrien_prime_2023,\n    title = {{PRIME}: a probabilistic neural network approach to solar wind propagation from {L1}},\n    volume = {10},\n    issn = {2296-987X},\n    shorttitle = {{PRIME}},\n    url = {https://www.frontiersin.org/articles/10.3389/fspas.2023.1250779/full},\n    doi = {10.3389/fspas.2023.1250779},\n    urldate = {2023-11-13},\n    journal = {Frontiers in Astronomy and Space Sciences},\n    author = {O\u2019Brien, Connor and Walsh, Brian M. and Zou, Ying and Tasnim, Samira and Zhang, Huaming and Sibeck, David Gary},\n    month = sep,\n    year = {2023},\n    pages = {1250779},\n}\n</code></pre>\n"}, {"fullname": "primesw.prime", "modulename": "primesw.prime", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "primesw.prime.prime", "modulename": "primesw.prime", "qualname": "prime", "kind": "class", "doc": "<p>Class to wrap a keras model to be used with the SW-trained PRIME architecture. It is recommended to instantiate <code>prime</code> objects in their default configuration:</p>\n\n<pre><code>import primesw as psw\npropagator = psw.prime()\n</code></pre>\n\n<p>Users will most likely use this class primarily for its <code>prime.predict</code> method.</p>\n\n<p>When instantiating a <code>prime</code> object, one can specify a predefined <code>model</code> to be used instead of the automatically-loaded PRIME model. \nIn that case, the scaling functions for the input and target datasets (<code>in_scaler</code> and <code>tar_scaler</code>), the input and target features (<code>in_keys</code> and <code>tar_keys</code>), and the output features (<code>out_keys</code>) must be specified.\nThe full list of arguments that can be passed to <code>prime</code> is given below.</p>\n", "bases": "keras.engine.training.Model"}, {"fullname": "primesw.prime.prime.__init__", "modulename": "primesw.prime", "qualname": "prime.__init__", "kind": "function", "doc": "<p><code>hps</code> is an array of dataset-pertinent hyperparameters. The three elements correspond to <code>window</code>, <code>input</code>, and <code>stride</code>:</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">model</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">in_scaler</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">tar_scaler</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">in_keys</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">tar_keys</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">out_keys</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">hps</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">60</span><span class=\"p\">,</span> <span class=\"mi\">15</span><span class=\"p\">,</span> <span class=\"mf\">0.08333333333333333</span><span class=\"p\">]</span></span>)</span>"}, {"fullname": "primesw.prime.prime.window", "modulename": "primesw.prime", "qualname": "prime.window", "kind": "variable", "doc": "<p>Length of input timeseries, in 100s units. Specified via <code>hps</code> argument.</p>\n"}, {"fullname": "primesw.prime.prime.stride", "modulename": "primesw.prime", "qualname": "prime.stride", "kind": "variable", "doc": "<p>Prediction lead time, in 100s units. Specified via <code>hps</code> argument.</p>\n"}, {"fullname": "primesw.prime.prime.fraction", "modulename": "primesw.prime", "qualname": "prime.fraction", "kind": "variable", "doc": "<p>Maximum fraction of input timeseries that can be interpolated, in 100s units. Specified via <code>hps</code> argument.</p>\n"}, {"fullname": "primesw.prime.prime.predict", "modulename": "primesw.prime", "qualname": "prime.predict", "kind": "function", "doc": "<p>Method that produces a dataframe of PRIME solar wind predictions.\nTo generate solar wind predictions from Wind spacecraft data, specify <code>start</code> and <code>stop</code> times for the desired prediction.\n<code>start</code> and <code>stop</code> are strings with format 'YYYY-MM-DD HH:MM:SS'.</p>\n\n<pre><code>import primesw as psw\npropagator = psw.prime()\npropagator.predict(start = '2020-01-01 00:00:00', stop = '2020-01-02 00:00:00')\n</code></pre>\n\n<p>If using data from an L1 monitor to make predictions, pass the input data using <code>input</code> argument.\nIf <code>input</code> is specified, <code>start</code> and <code>stop</code> should not be (and vice versa).\n<code>input</code> is also useful for making predicitons from synthetic solar wind data (see <code>prime.build_synth_input</code>).\nFor instance, one can predict what the solar wind at the bow shock nose would be if the solar wind flow at L1 was 700km/s:</p>\n\n<pre><code>import primesw as psw\npropagator = psw.prime()\npropagator.predict(input = propagator.build_synth_input(vx=-700))\n</code></pre>\n\n<p>By default, predictions are made at the average location of the nose of Earth's bow shock 13.25 Earth Radii upstream on the Geocentric Solar Ecliptic (GSE) x-axis.\nOne can also specify a position to propagate to besides the default by specifying <code>pos</code>:</p>\n\n<pre><code>import primesw as psw\npropagator = psw.prime()\npropagator.predict(start = '2020-01-01 00:00:00', stop = '2020-01-02 00:00:00', pos = [13.25, 5, 0])\n</code></pre>\n\n<p>All positions are in GSE coordinates with units of Earth Radii.\nIt is not recommended to make predictions outside of the region PRIME was trained on (within 30 Earth radii of the Earth on the dayside).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"nb\">input</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">start</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">stop</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">pos</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mf\">13.25</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "primesw.prime.prime.predict_raw", "modulename": "primesw.prime", "qualname": "prime.predict_raw", "kind": "function", "doc": "<p>Generates PRIME predictions from input dataframe. Assumes that <code>input</code> has keys specified by <code>prime.in_keys</code>. It is generally recommended to use <code>prime.predict</code> instead.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"nb\">input</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "primesw.prime.prime.predict_grid", "modulename": "primesw.prime", "qualname": "prime.predict_grid", "kind": "function", "doc": "<p>Generate predictions from PRIME on a grid of points in GSE coordinates.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<ul>\n<li>gridsize (float): Spacing of grid points (RE)</li>\n<li>x_extent (list): Range of x values to calculate on (GSE RE).</li>\n<li>framenum (int): Number of frames to calculate (GSE RE).</li>\n<li>bx (float, array-like): IMF Bx value (nT). If array like, must be of length framenum.</li>\n<li>by (float, array-like): IMF By value (nT). If array like, must be of length framenum.</li>\n<li>bz (float, array-like): IMF Bz value (nT). If array like, must be of length framenum.</li>\n<li>vx (float, array-like): Solar wind Vx value (km/s). If array like, must be of length framenum.</li>\n<li>vy (float, array-like): Solar wind Vy value (km/s). If array like, must be of length framenum.</li>\n<li>vz (float, array-like): Solar wind Vz value (km/s). If array like, must be of length framenum.</li>\n<li>ni (float, array-like): Solar wind ion density value (cm^-3). If array like, must be of length framenum.</li>\n<li>vt (float, array-like): Solar wind ion thermal speed value (km/s). If array like, must be of length framenum.</li>\n<li>rx (float, array-like): Wind spacecraft position x value (GSE RE). If array like, must be of length framenum.</li>\n<li>ry (float, array-like): Wind spacecraft position y value (GSE RE). If array like, must be of length framenum.</li>\n<li>rz (float, array-like): Wind spacecraft position z value (GSE RE). If array like, must be of length framenum.</li>\n<li>y_extent (list): Range of y values to calculate on (GSE RE). If None, z_extent must be specified.</li>\n<li>z_extent (list): Range of z values to calculate on (GSE RE). If None, y_extent must be specified.</li>\n<li>y (float, array-like): Y position (GSE RE) that is held constant if y_extent is not specified. Default 0.</li>\n<li>z (float, array-like): Z position (GSE RE) that is held constant if z_extent is not specified. Default 0.</li>\n<li><p>subtract_ecliptic (bool): Whether or not to subtract the Earth's motion in the ecliptic from Vy. Default False.</p>\n\n<h2 id=\"returns\">Returns:</h2></li>\n<li><p>output_grid (ndarray): Array of predicted values on the grid. Shape (framenum, x_extent/gridsize, y_extent/gridsize, 14). Features as in <code>prime.out_keys</code>.</p></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">gridsize</span>,</span><span class=\"param\">\t<span class=\"n\">x_extent</span>,</span><span class=\"param\">\t<span class=\"n\">framenum</span>,</span><span class=\"param\">\t<span class=\"n\">bx</span>,</span><span class=\"param\">\t<span class=\"n\">by</span>,</span><span class=\"param\">\t<span class=\"n\">bz</span>,</span><span class=\"param\">\t<span class=\"n\">vx</span>,</span><span class=\"param\">\t<span class=\"n\">vy</span>,</span><span class=\"param\">\t<span class=\"n\">vz</span>,</span><span class=\"param\">\t<span class=\"n\">ni</span>,</span><span class=\"param\">\t<span class=\"n\">vt</span>,</span><span class=\"param\">\t<span class=\"n\">rx</span>,</span><span class=\"param\">\t<span class=\"n\">ry</span>,</span><span class=\"param\">\t<span class=\"n\">rz</span>,</span><span class=\"param\">\t<span class=\"n\">y_extent</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">z_extent</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">z</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">subtract_ecliptic</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "primesw.prime.prime.build_model", "modulename": "primesw.prime", "qualname": "prime.build_model", "kind": "function", "doc": "<p>Builds the underlying PRIME model with no weights or biases loaded. Deprecated as of keras introducing the <code>.keras</code> model save routine.\nUnits are the layer size of the GRU layer and three dense layers.\nNormalization and dropout applied at each layer.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">units</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">352</span><span class=\"p\">,</span> <span class=\"mi\">192</span><span class=\"p\">,</span> <span class=\"mi\">48</span><span class=\"p\">,</span> <span class=\"mi\">48</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">activation</span><span class=\"o\">=</span><span class=\"s1\">&#39;elu&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">dropout</span><span class=\"o\">=</span><span class=\"mf\">0.2</span>,</span><span class=\"param\">\t<span class=\"n\">lr</span><span class=\"o\">=</span><span class=\"mf\">0.0001</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "primesw.prime.prime.build_synth_input", "modulename": "primesw.prime", "qualname": "prime.build_synth_input", "kind": "function", "doc": "<p>Builds a synthetic input array from user-specified quantities at L1.\nFor input arrays made from measured data at L1, see <code>prime.build_real_input</code>.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<ul>\n<li>epoch (datetime): Datetime of start of input Dataframe.</li>\n<li>bx (float, array-like): IMF Bx value (nT).</li>\n<li>by (float, array-like): IMF By value (nT).</li>\n<li>bz (float, array-like): IMF Bz value (nT).</li>\n<li>vx (float, array-like): Solar wind Vx value ().</li>\n<li>vy (float, array-like): Solar wind Vy value.</li>\n<li>vz (float, array-like): Solar wind Vz value.</li>\n<li>ni (float, array-like): Solar wind ion density value.</li>\n<li>vt (float, array-like): Solar wind ion thermal speed value.</li>\n<li>rx (float, array-like): Wind spacecraft position x value.</li>\n<li>ry (float, array-like): Wind spacecraft position y value.</li>\n<li>rz (float, array-like): Wind spacecraft position z value.</li>\n<li>tar_rx (float, array-like): Propagation target position x value.</li>\n<li>tar_ry (float, array-like): Propagation target position y value.</li>\n<li>tar_rz (float, array-like): Propagation target position z value.</li>\n</ul>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<ul>\n<li>input (Dataframe): Input dataframe suitable to predict from with self.predict().</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">epoch</span><span class=\"o\">=</span><span class=\"n\">Timestamp</span><span class=\"p\">(</span><span class=\"s1\">&#39;1970-01-01 00:00:00+0000&#39;</span><span class=\"p\">,</span> <span class=\"n\">tz</span><span class=\"o\">=</span><span class=\"s1\">&#39;UTC&#39;</span><span class=\"p\">)</span>,</span><span class=\"param\">\t<span class=\"n\">bx</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">by</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">bz</span><span class=\"o\">=-</span><span class=\"mi\">5</span>,</span><span class=\"param\">\t<span class=\"n\">vx</span><span class=\"o\">=-</span><span class=\"mi\">400</span>,</span><span class=\"param\">\t<span class=\"n\">vy</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">vz</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">ni</span><span class=\"o\">=</span><span class=\"mi\">5</span>,</span><span class=\"param\">\t<span class=\"n\">vt</span><span class=\"o\">=</span><span class=\"mi\">30</span>,</span><span class=\"param\">\t<span class=\"n\">rx</span><span class=\"o\">=</span><span class=\"mi\">200</span>,</span><span class=\"param\">\t<span class=\"n\">ry</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">rz</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">tar_rx</span><span class=\"o\">=</span><span class=\"mf\">13.25</span>,</span><span class=\"param\">\t<span class=\"n\">tar_ry</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">tar_rz</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "primesw.prime.prime.build_real_input", "modulename": "primesw.prime", "qualname": "prime.build_real_input", "kind": "function", "doc": "<p>Load Wind spacecraft input data for PRIME in between specified date strings.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<ul>\n<li>start (string): The start date of the data to load ('YYYY-MM-DD')</li>\n<li>end (string): The end date of the data to load ('YYYY-MM-DD')</li>\n<li>pos (list): Location of propagation in GSE coordinates (Earth Radii). Default [13.25, 0, 0].</li>\n<li><p>load_freq (string): Max length of data loaded by CdasWs. If throwing RuntimeError, try modifying this parameter. Default '3M' (three months).</p>\n\n<h2 id=\"return\">Return:</h2></li>\n<li><p>input (Dataframe): Input dataframe suitable to predict from with self.predict().</p></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">start</span>, </span><span class=\"param\"><span class=\"n\">stop</span>, </span><span class=\"param\"><span class=\"n\">pos</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mf\">13.25</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">load_freq</span><span class=\"o\">=</span><span class=\"s1\">&#39;3M&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "primesw.prime.crps_loss", "modulename": "primesw.prime", "qualname": "crps_loss", "kind": "function", "doc": "<p>Tensorflow implementation of the Continuous Rank Probability Score loss function. Assumes seven output features. For a simpler functional version, see <code>primesw.crps_f</code>.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<ul>\n<li>y_true (tf.Tensor): Ground truth values of predicted variable.</li>\n<li>y_pred (tf.Tensor): mu and sigma^2 values of predicted distribution.</li>\n</ul>\n\n<h2 id=\"returns\">Returns</h2>\n\n<ul>\n<li>crps (tf.Tensor): Continuous rank probability score.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">y_true</span>, </span><span class=\"param\"><span class=\"n\">y_pred</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "primesw.prime.mse_metric", "modulename": "primesw.prime", "qualname": "mse_metric", "kind": "function", "doc": "<p>Tensorflow implementation of Mean Squared Error compatible with PRIME's output layer. Assumes seven output features. Not suitable for use as a loss function.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<ul>\n<li>y_true (tf.Tensor): Ground truth values of predicted variable.</li>\n<li>y_pred (tf.Tensor): mu and sigma^2 values of predicted distribution.</li>\n</ul>\n\n<h2 id=\"returns\">Returns</h2>\n\n<ul>\n<li>mse (tf.Tensor): MSE between mu and y_true.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">y_true</span>, </span><span class=\"param\"><span class=\"n\">y_pred</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "primesw.primesh", "modulename": "primesw.primesh", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "primesw.primesh.primesh", "modulename": "primesw.primesh", "qualname": "primesh", "kind": "class", "doc": "<p>Class to wrap a keras model to be used with the Sheath-trained PRIME-SH architecture (for solar wind prediction see <code>primesw.prime</code>). It is recommended to instantiate <code>primesh</code> objects in their default configuration:</p>\n\n<pre><code>import primesw as psw\npropagator = psw.primesh()\n</code></pre>\n\n<p>Users will most likely use this class primarily for its <code>primesh.predict</code> method. This method is inherited from <code>primesw.prime</code> and thus operates the same way.\nTo generate solar wind predictions from Wind spacecraft data, specify <code>start</code> and <code>stop</code> times for the desired prediction.\n<code>start</code> and <code>stop</code> are strings with format 'YYYY-MM-DD HH:MM:SS'.</p>\n\n<pre><code>import primesw as psw\npropagator = psw.primesh()\npropagator.predict(start = '2020-01-01 00:00:00', stop = '2020-01-02 00:00:00')\n</code></pre>\n\n<p>If using data from an L1 monitor to make predictions, pass the input data using <code>input</code> argument.\nIf <code>input</code> is specified, <code>start</code> and <code>stop</code> should not be (and vice versa).\n<code>input</code> is also useful for making predicitons from synthetic solar wind data (see inherited method <code>primesw.prime.build_synth_input</code>).\nFor instance, one can predict what the magnetosheath conditions at the magnetopause nose would be if the solar wind flow at L1 was 700km/s:</p>\n\n<pre><code>import primesw as psw\npropagator = psw.primesh()\npropagator.predict(input = propagator.build_synth_input(vx=-700))\n</code></pre>\n\n<p>By default, predictions are made at the average middle of Earth's magnetosheath 12.25 Earth Radii upstream on the Geocentric Solar Ecliptic (GSE) x-axis.\nOne can also specify a position to propagate to besides the default by specifying <code>pos</code>:</p>\n\n<pre><code>import primesw as psw\npropagator = psw.primesh()\npropagator.predict(start = '2020-01-01 00:00:00', stop = '2020-01-02 00:00:00', pos = [11.25, 5, 0])\n</code></pre>\n\n<p>All positions are in GSE coordinates with units of Earth Radii.\nIt is not recommended to make predictions outside of the region PRIME-SH was trained on (within 30 Earth radii of the Earth on the dayside).</p>\n\n<p>When instantiating a <code>primesh</code> object, one can specify a predefined <code>model</code> to be used instead of the automatically-loaded PRIME-SH model. \nIn that case, the scaling functions for the input and target datasets (<code>in_scaler</code> and <code>tar_scaler</code>), the input and target features (<code>in_keys</code> and <code>tar_keys</code>), and the output features (<code>out_keys</code>) must be specified.\nThe full list of arguments that can be passed to <code>primesh</code> is given below.</p>\n", "bases": "primesw.prime.prime"}, {"fullname": "primesw.primesh.primesh.__init__", "modulename": "primesw.primesh", "qualname": "primesh.__init__", "kind": "function", "doc": "<p><code>hps</code> is an array of dataset-pertinent hyperparameters. The three elements correspond to <code>window</code>, <code>input</code>, and <code>stride</code>:</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">model</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">in_scaler</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">tar_scaler</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">loc_scaler</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">in_keys</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">tar_keys</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">out_keys</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">hps</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">55</span><span class=\"p\">,</span> <span class=\"mi\">18</span><span class=\"p\">,</span> <span class=\"mf\">0.05</span><span class=\"p\">]</span></span>)</span>"}, {"fullname": "primesw.primesh.primesh.window", "modulename": "primesw.primesh", "qualname": "primesh.window", "kind": "variable", "doc": "<p>Length of input timeseries, in 100s units. Specified via <code>hps</code> argument.</p>\n"}, {"fullname": "primesw.primesh.primesh.stride", "modulename": "primesw.primesh", "qualname": "primesh.stride", "kind": "variable", "doc": "<p>Prediction lead time, in 100s units. Specified via <code>hps</code> argument.</p>\n"}, {"fullname": "primesw.primesh.primesh.fraction", "modulename": "primesw.primesh", "qualname": "primesh.fraction", "kind": "variable", "doc": "<p>Maximum fraction of input timeseries that can be interpolated, in 100s units. Specified via <code>hps</code> argument.</p>\n"}, {"fullname": "primesw.primesh.primesh.predict_raw", "modulename": "primesw.primesh", "qualname": "primesh.predict_raw", "kind": "function", "doc": "<p>Wrapper function to predict with a keras model. Differs from <code>prime.predict_raw</code> by the inclusion of separate location scaling. Not recommended for direct use, see <code>prime.predict</code> instead.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"nb\">input</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "primesw.primesh.primesh.predict_grid", "modulename": "primesw.primesh", "qualname": "primesh.predict_grid", "kind": "function", "doc": "<p>Generate predictions from PRIME on a grid of points in GSE coordinates.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<ul>\n<li>gridsize (float): Spacing of grid points (RE)</li>\n<li>x_extent (list): Range of x values to calculate on (GSE RE).</li>\n<li>framenum (int): Number of frames to calculate (GSE RE).</li>\n<li>bx (float, array-like): IMF Bx value (nT). If array like, must be of length framenum.</li>\n<li>by (float, array-like): IMF By value (nT). If array like, must be of length framenum.</li>\n<li>bz (float, array-like): IMF Bz value (nT). If array like, must be of length framenum.</li>\n<li>vx (float, array-like): Solar wind Vx value (km/s). If array like, must be of length framenum.</li>\n<li>vy (float, array-like): Solar wind Vy value (km/s). If array like, must be of length framenum.</li>\n<li>vz (float, array-like): Solar wind Vz value (km/s). If array like, must be of length framenum.</li>\n<li>ni (float, array-like): Solar wind ion density value (cm^-3). If array like, must be of length framenum.</li>\n<li>vt (float, array-like): Solar wind ion thermal speed value (km/s). If array like, must be of length framenum.</li>\n<li>rx (float, array-like): Wind spacecraft position x value (GSE RE). If array like, must be of length framenum.</li>\n<li>ry (float, array-like): Wind spacecraft position y value (GSE RE). If array like, must be of length framenum.</li>\n<li>rz (float, array-like): Wind spacecraft position z value (GSE RE). If array like, must be of length framenum.</li>\n<li>y_extent (list): Range of y values to calculate on (GSE RE). If None, z_extent must be specified.</li>\n<li>z_extent (list): Range of z values to calculate on (GSE RE). If None, y_extent must be specified.</li>\n<li>y (float, array-like): Y position (GSE RE) that is held constant if y_extent is not specified. Default 0.</li>\n<li>z (float, array-like): Z position (GSE RE) that is held constant if z_extent is not specified. Default 0.</li>\n<li><p>subtract_ecliptic (bool): Whether or not to subtract the Earth's motion in the ecliptic from Vy. Default False.</p>\n\n<h2 id=\"returns\">Returns:</h2></li>\n<li><p>output_grid (ndarray): Array of predicted values on the grid. Shape (framenum, x_extent/gridsize, y_extent/gridsize, 14). Features as in <code>prime.out_keys</code>.</p></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">gridsize</span>,</span><span class=\"param\">\t<span class=\"n\">x_extent</span>,</span><span class=\"param\">\t<span class=\"n\">framenum</span>,</span><span class=\"param\">\t<span class=\"n\">bx</span>,</span><span class=\"param\">\t<span class=\"n\">by</span>,</span><span class=\"param\">\t<span class=\"n\">bz</span>,</span><span class=\"param\">\t<span class=\"n\">vx</span>,</span><span class=\"param\">\t<span class=\"n\">vy</span>,</span><span class=\"param\">\t<span class=\"n\">vz</span>,</span><span class=\"param\">\t<span class=\"n\">ni</span>,</span><span class=\"param\">\t<span class=\"n\">vt</span>,</span><span class=\"param\">\t<span class=\"n\">rx</span>,</span><span class=\"param\">\t<span class=\"n\">ry</span>,</span><span class=\"param\">\t<span class=\"n\">rz</span>,</span><span class=\"param\">\t<span class=\"n\">y_extent</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">z_extent</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">z</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">loc_mask</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">subtract_ecliptic</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "primesw.primesh.jelinek_bs", "modulename": "primesw.primesh", "qualname": "jelinek_bs", "kind": "function", "doc": "<p>Bow shock model from Jelinek et al 2012. Assumes GSE Z=0 RE.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<ul>\n<li>y (float): GSE Y coordinate (RE)</li>\n<li>pdyn (float): Solar wind dynamic pressure (nPa)</li>\n<li>r0 (float): Bow shock average standoff distance tuning parameter (RE)</li>\n<li>l (float): Lambda tuning parameter</li>\n<li><p>e (float): Epsilon tuning parameter</p>\n\n<h2 id=\"returns\">Returns:</h2></li>\n<li><p>bs_x (float): GSE X position of bow shock (RE)</p></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">y</span>, </span><span class=\"param\"><span class=\"n\">pdyn</span>, </span><span class=\"param\"><span class=\"n\">r0</span><span class=\"o\">=</span><span class=\"mf\">15.02</span>, </span><span class=\"param\"><span class=\"n\">l</span><span class=\"o\">=</span><span class=\"mf\">1.17</span>, </span><span class=\"param\"><span class=\"n\">e</span><span class=\"o\">=</span><span class=\"mf\">6.55</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "primesw.primesh.shue_mp", "modulename": "primesw.primesh", "qualname": "shue_mp", "kind": "function", "doc": "<p>Magnetopause model from Shue et al 1998. Assumes GSE Z=0 RE.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<ul>\n<li>theta (float): Polar angle position of desired MP location (radians)</li>\n<li>pdyn (float): Solar wind dynamic pressure (nPa)</li>\n<li>bz (float): IMF Bz (nT)\nReturns:</li>\n<li>rmp (float): Magnetopause radial distance to Earth (RE)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">theta</span>, </span><span class=\"param\"><span class=\"n\">pdyn</span>, </span><span class=\"param\"><span class=\"n\">bz</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();